// tb_calculator.cpp
#include <mpi.h>
#include "Vcalculator.h"       // Generated by Verilator
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <svdpi.h>
#include <cstdint>
#include <iostream>
using namespace std;

int tile0 = 10;
int tile1 = 11;
int tile2 = 12;
int tile3 = 13;
int tile4 = 14;
int tile5 = 15;
int tile6 = 16;
int tile7 = 17;
int tile8 = 18;

typedef struct
{
    unsigned int TILE_X;
    unsigned int TILE_Y;
    unsigned long long in_a_n;
    unsigned long long in_b_n;
    unsigned int in_ctrl_n;
    bool in_valid_n;
    unsigned long long in_a_e;
    unsigned long long in_b_e;
    unsigned int in_ctrl_e;
    bool in_valid_e;
    unsigned long long in_a_s;
    unsigned long long in_b_s;
    unsigned int in_ctrl_s;
    bool in_valid_s;
    unsigned long long in_a_w;
    unsigned long long in_b_w;
    unsigned int in_ctrl_w;
    bool in_valid_w;
    unsigned long long host_in_a;
    unsigned long long host_in_b;
    unsigned int host_in_ctrl;
    bool host_in_valid;
} mpi_all_req;

typedef struct
{
    unsigned long long out_a_n;
    unsigned long long out_b_n;
    unsigned int out_ctrl_n;
    bool out_valid_n;
    unsigned long long out_a_e;
    unsigned long long out_b_e;
    unsigned int out_ctrl_e;
    bool out_valid_e;
    unsigned long long out_a_s;
    unsigned long long out_b_s;
    unsigned int out_ctrl_s;
    bool out_valid_s;
    unsigned long long out_a_w;
    unsigned long long out_b_w;
    unsigned int out_ctrl_w;
    bool out_valid_w;
    unsigned long long host_out_a;
    bool host_out_valid;

} mpi_all_resp;

void initialize();
void mpi_send_request(mpi_all_req message, int dest, int rank, int flag);
mpi_all_resp mpi_receive_response(int origin, int flag);
int getRank();
int getSize();
void finalize();
void mpi_send_finish();

// === MPI Functions ===
void mpi_request(unsigned int TILE_X, unsigned int TILE_Y, unsigned long long in_a_n, unsigned long long in_b_n, unsigned int in_ctrl_n, bool in_valid_n, unsigned long long in_a_e, unsigned long long in_b_e, unsigned int in_ctrl_e, bool in_valid_e, unsigned long long in_a_s, unsigned long long in_b_s, unsigned int in_ctrl_s, bool in_valid_s, unsigned long long in_a_w, unsigned long long in_b_w, unsigned int in_ctrl_w, bool in_valid_w, unsigned long long host_in_a, unsigned long long host_in_b, unsigned int host_in_ctrl, bool host_in_valid)
{
    mpi_all_req message;
    message.TILE_X = TILE_X;
    message.TILE_Y = TILE_Y;
    message.in_a_n = in_a_n;
    message.in_b_n = in_b_n;
    message.in_ctrl_n = in_ctrl_n;
    message.in_valid_n = in_valid_n;
    message.in_a_e = in_a_e;
    message.in_b_e = in_b_e;
    message.in_ctrl_e = in_ctrl_e;
    message.in_valid_e = in_valid_e;
    message.in_a_s = in_a_s;
    message.in_b_s = in_b_s;
    message.in_ctrl_s = in_ctrl_s;
    message.in_valid_s = in_valid_s;
    message.in_a_w = in_a_w;
    message.in_b_w = in_b_w;
    message.in_ctrl_w = in_ctrl_w;
    message.in_valid_w = in_valid_w;
    message.host_in_a = host_in_a;
    message.host_in_b = host_in_b;
    message.host_in_ctrl = host_in_ctrl;
    message.host_in_valid = host_in_valid;
    int dest; int req_flag;
    if(TILE_X == 0 && TILE_Y == 0) {dest = 1; req_flag = tile0; }
    else if(TILE_X == 0 && TILE_Y == 1) {dest = 2; req_flag = tile1; }
    else if(TILE_X == 0 && TILE_Y == 2) {dest = 3; req_flag = tile2; }
    else if(TILE_X == 1 && TILE_Y == 0) {dest = 4; req_flag = tile3; }
    else if(TILE_X == 1 && TILE_Y == 1) {dest = 5; req_flag = tile4; }
    else if(TILE_X == 1 && TILE_Y == 2) {dest = 6; req_flag = tile5; }
    else if(TILE_X == 2 && TILE_Y == 0) {dest = 7; req_flag = tile6; }
    else if(TILE_X == 2 && TILE_Y == 1) {dest = 8; req_flag = tile7; }
    else if(TILE_X == 2 && TILE_Y == 2) {dest = 9; req_flag = tile8; }

    cout << "2. Sending the operands from dpi-mpi-sim.cpp to mpi-lib-tile.cpp and dest is "<< dest << endl;
    mpi_send_request(message, dest, 0, req_flag); // have to figure out
}

mpi_all_resp mpi_response(int origin, int resp_flag)
{
    mpi_all_resp message;
    message = mpi_receive_response(origin, resp_flag);
    return message;
}

// === DPI-MPI Conversion ===
extern "C" void dpi_tile(unsigned int TILE_X, unsigned int TILE_Y, unsigned long long in_a_n, unsigned long long in_b_n, unsigned int in_ctrl_n, bool in_valid_n, unsigned long long in_a_e, unsigned long long in_b_e, unsigned int in_ctrl_e, bool in_valid_e, unsigned long long in_a_s, unsigned long long in_b_s, unsigned int in_ctrl_s, bool in_valid_s, unsigned long long in_a_w, unsigned long long in_b_w, unsigned int in_ctrl_w, bool in_valid_w, unsigned long long host_in_a, unsigned long long host_in_b, unsigned int host_in_ctrl, bool host_in_valid, unsigned long long *out_a_n, unsigned long long *out_b_n, unsigned int *out_ctrl_n, bool *out_valid_n, unsigned long long *out_a_e, unsigned long long *out_b_e, unsigned int *out_ctrl_e, bool *out_valid_e, unsigned long long *out_a_s, unsigned long long *out_b_s, unsigned int *out_ctrl_s, bool *out_valid_s, unsigned long long *out_a_w, unsigned long long *out_b_w, unsigned int *out_ctrl_w, bool *out_valid_w, unsigned long long *host_out_a, bool *host_out_valid)
{
    mpi_all_resp resp_message;

    cout << "1. Entered DPI-MPI interface for tile!" << endl;
    mpi_request(TILE_X, TILE_Y, in_a_n, in_b_n, in_ctrl_n, in_valid_n, in_a_e, in_b_e, in_ctrl_e, in_valid_e, in_a_s, in_b_s, in_ctrl_s, in_valid_s, in_a_w, in_b_w, in_ctrl_w, in_valid_w, host_in_a, host_in_b, host_in_ctrl, host_in_valid);
    if(TILE_X == 0 && TILE_Y == 0) resp_message = mpi_response(1, tile0);  
    else if(TILE_X == 0 && TILE_Y == 1) resp_message = mpi_response(2, tile1);  
    else if(TILE_X == 0 && TILE_Y == 2) resp_message = mpi_response(3, tile2);  
    else if(TILE_X == 1 && TILE_Y == 0) resp_message = mpi_response(4, tile3);  
    else if(TILE_X == 1 && TILE_Y == 1) resp_message = mpi_response(5, tile4);  
    else if(TILE_X == 1 && TILE_Y == 2) resp_message = mpi_response(6, tile5);  
    else if(TILE_X == 2 && TILE_Y == 0) resp_message = mpi_response(7, tile6);  
    else if(TILE_X == 2 && TILE_Y == 1) resp_message = mpi_response(8, tile7);  
    else if(TILE_X == 2 && TILE_Y == 2) resp_message = mpi_response(9, tile8);  

    *out_a_n = resp_message.out_a_n;
    *out_b_n = resp_message.out_b_n;
    *out_ctrl_n = resp_message.out_ctrl_n;
    *out_valid_n = resp_message.out_valid_n;

    *out_a_e = resp_message.out_a_e;
    *out_b_e = resp_message.out_b_e;
    *out_ctrl_e = resp_message.out_ctrl_e;
    *out_valid_e = resp_message.out_valid_e;

    *out_a_s = resp_message.out_a_s;
    *out_b_s = resp_message.out_b_s;
    *out_ctrl_s = resp_message.out_ctrl_s;
    *out_valid_s = resp_message.out_valid_s;

    *out_a_w = resp_message.out_a_w;
    *out_b_w = resp_message.out_b_w;
    *out_ctrl_w = resp_message.out_ctrl_w;
    *out_valid_w = resp_message.out_valid_w;

    *host_out_a = resp_message.host_out_a;
    *host_out_valid = resp_message.host_out_valid;

    return;
}

// === Sim + MPI ===
int main(int argc, char **argv, char **env)
{
    Verilated::commandArgs(argc, argv);
    Vcalculator *top = new Vcalculator;
    initialize();

    // Enable VCD trace
    Verilated::traceEverOn(true);
    // VerilatedVcdC *trace = new VerilatedVcdC;
    // top->trace(trace, 99);
    // trace->open("tb_calculator.vcd");

    int rank, size, dest;
    rank = getRank();
    size = getSize();

    std::cout << "Calculator size: " << size << ", rank: " << rank << std::endl;

    // Operation names corresponding to each mode
    const std::string op_names[] = {
        "ADD",      // 0
        "SUB",      // 1
        "MUL",      // 2
        "DIV",      // 3
        "AND",      // 4
        "OR",       // 5
        "XOR",      // 6
        "SLL",      // 7 (shift left logical)
        "SRL"       // 8 (shift right logical)
    };

    // Three test input pairs
    uint64_t a_vals[] = {20, 8, 7};
    uint64_t b_vals[] = {3,  4, 2};

    int cycles = 0;

    // Loop through each input pair
    for (int i = 0; i < 3; i++) {
        // Test all modes for this pair
        for (uint8_t mode = 0; mode <= 8; mode++) {
            top->a = a_vals[i];
            top->b = b_vals[i];
            top->mode = mode;

            // Eval (no clock here, purely combinational)
            top->eval();
            // trace->dump(cycles++);

            std::cout << "[test "<<i
                      << "] a=" << top->a
                      << " b=" << top->b
                      << " mode=" << int(top->mode)
                      << " (" << op_names[mode] << ")"
                      << " valid=" << int(top->valid)
                      << " result=" << top->result
                      << std::endl;
        }
    }

    mpi_send_finish();
    finalize();
    // Finish
    top->final();
    // trace->close();
    delete top;
    // delete trace;
    return 0;
}

